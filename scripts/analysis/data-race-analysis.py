#!/usr/bin/python

import sys
from collections import defaultdict


# Usage
# sys.argv[1] is the path of the .map file
# sys.argv[2] is the path of the race detector result
# sys.argv[1] controls how many lines of source code you want to see

# Map format (argv[1]):
# instruction_address function_name source_code_location
# c100000d startup_32 /local/pfonseca/piking/kernel-build/linux-3.13.5-fs-static2/arch/x86/kernel/head_32.S:94
# .map file is generated by generate-kernel-map.sh and generate-kernel-map-slave.sh

# Data race format (argv[2]):
# T: filename of the trace S: interleaving I1: test id on CPU0 I2: test id on CPU1 IP1: race instruction IP2: race instruction PMA1: physical memory address of the accessed memory
# PMA2: physical memory address of the accessed memory CPU1: CPU ran IP1 CPU2: CPU ran IP2 R1: if IP1 is read R2: if IP2 is read L1: number of bytes IP1 access L2: number of bytes IP2 access
# IC1: number of instructions executed before IP1 IC2: number of instructions executed before IP2
# T: trace_20140320_234306_3_3_1017.txt S: 1017 I1: 3 I2: 3 IP1: c12cc94d IP2: c12cc93f PMA1: fbbc95c PMA2: fbbc95c CPU1: 0 CPU2: 1 R1: 0 R2: 1 L1: 4 L2: 4 IC1: 215300 IC2: 209731
# T: trace_20140320_234306_3_3_1017.txt S: 1017 I1: 3 I2: 3 IP1: c12cc94d IP2: c12cc93f PMA1: fbbc95c PMA2: fbbc95c CPU1: 3 CPU2: 1 R1: 0 R2: 1 L1: 4 L2: 4 IC1: 217780 IC2: 209731


fmap_ip_source = open(sys.argv[1])
map_ip_source={}
ip_list = []
for line in fmap_ip_source:
    a = line.split(":")
    a[0] = a[0][2:len(a[0])]
    map_ip_source[a[0]] = line.strip()
    ip_list.append(a[0])
print("vmlinux map is loaded")
results = {}
ip_count = defaultdict(int)
ip_pairs_count = defaultdict(int)
ip_last_pair = {}

def last_ip(ip_list, ip):
    return ip_list[ip_list.index(ip)-1]

def new_pair(x, y):
    #print "Adding pair ", x, y
    ip_count[x]+=1
    ip_count[y]+=1

    # str comparison to order the ips, this way we don't count twice the same pair in different orders
    if(x<y):
        ip_pairs_count[x+":"+y]+=1
    else:
        ip_pairs_count[y+":"+x]+=1

    if x in results and y in results:
        #print "Both exist"
        # pair_x and pair_y should be a defaultdict
        pair_x = results[x]
        pair_y = results[y]
        if pair_x == pair_y:
            pair = pair_x
            pair[x] += 1
            pair[y] += 1
        else:
            pair_x.update(pair_y)
            pair = pair_x
            #print pair
            for x in pair:
                results[x]=pair

    elif x not in results and y not in results:
        #print "New"
        pair=defaultdict(int)
        pair[x]+=1
        pair[y]+=1
        results[x]=pair
        results[y]=pair

    elif x in results:
        #print "X exists"
        pair = results[x]
        pair[x]+=1
        pair[y]+=1
        results[y]=pair

    elif y in results:
        #print "Y exists"
        pair = results[y]
        pair[x]+=1
        pair[y]+=1
        results[x]=pair


print("Waiting for data race records\n")
# maybe read data races from the file
# sys.argv[2] should be the filename of the race detector result

data_races = open(sys.argv[2])
#for x in sys.stdin:
data_races  = data_races.readlines()
total_data_race = len(data_races)
current_num = 0
for x in data_races:
    current_num += 1
    #print("receive ", x)
    fields=x.split(" ")
    new_pair(fields[9], fields[11])
    # sishuai
    # fields[9] is IP1, fields[11] is IP2
    # the x below is the whole data race record
    ip_last_pair[fields[9]] = x.strip() +'\n'
    ip_last_pair[fields[11]] = x.strip() +'\n'
    if current_num % 500 == 0:
        print("Analyed ", current_num, total_data_race, " data races in total")

v = defaultdict(int)

for x in results:
    #print results[x]
    #print results[x].keys()
    s = frozenset(results[x].keys())
    # print s
    if s not in v:
        # results[x] is a dictionary where the key is race instructions involved
        for i in results[x]:
            v[s]+=results[x][i]

for x in sorted(v, key=v.get):
    print "=" * 180
    print "Total: " + str(v[x]) + "\tAddresses:",
    for ip in x:
        # Print all the ips involved in the race cluster
        print ip,
    print

    # Print the individual ip count, the map result
    l_eips = list(x)
    for ip in sorted(l_eips,key=ip_count.get):
        if ip in map_ip_source:
            if map_ip_source[ip].find("_once") == -1 and map_ip_source[ip].find("atomic") == -1 and map_ip_source[ip].find("list") == -1:
                print  str(ip_count[ip]) + "\t" + map_ip_source[ip]
            else:
                previous_ip = last_ip(ip_list, ip)
                while (map_ip_source[previous_ip].find("_once") != -1 or map_ip_source[previous_ip].find("atomic") != -1 or map_ip_source[previous_ip].find("list") !=-1):
                    previous_ip = last_ip(ip_list, previous_ip)
                print  str(ip_count[ip]) + "\t" + map_ip_source[previous_ip]
        else:
            print  str(ip_count[ip]) + "\t" + ip + " Not found"
    print
    for ip in sorted(l_eips,key=ip_count.get):
        if ip in map_ip_source:
            print  str(ip_count[ip]) + "\t"  + ip + " " +  map_ip_source[ip].split(" ")[1] + " " + ip_last_pair[ip].strip()
        else:
            print  str(ip_count[ip]) + "\t" + ip + " Not found " + ip_last_pair[ip].strip()
    print

print "++++++++++++++++++++++++"
print "STATS: Distinct IPs: " + str(len(ip_count)) + " Distinct pairs: " + str(len(ip_pairs_count)) + " Distinct clusters: " + str(len(v))
print "++++++++++++++++++++++++"
